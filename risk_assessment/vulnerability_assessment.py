"""
Vulnerability assessment module for checking CVEs and security issues.
"""

import json
import re
import time
import logging
from typing import List, Optional
from tavily import TavilyClient
from langchain_google_genai import ChatGoogleGenerativeAI

from .models import Vulnerability, VulnerabilityAssessment, Severity
from .cve_client import CVEDatabaseClient
from .utils import calculate_cost

logger = logging.getLogger(__name__)

DESCRIPTION_MAX_LENGTH = 200

def parse_severity_from_cvss(cvss_score: float) -> Severity:
    """
    Parse severity from CVSS score (NIST standard).
    More reliable than string matching.
    
    Args:
        cvss_score: CVSS score (0.0-10.0)
    
    Returns:
        Severity enum based on standard CVSS ranges
    """
    if cvss_score >= 9.0:
        return Severity.CRITICAL
    elif cvss_score >= 7.0:
        return Severity.HIGH
    elif cvss_score >= 4.0:
        return Severity.MEDIUM
    elif cvss_score > 0:
        return Severity.LOW
    else:
        return Severity.UNKNOWN


def parse_severity(severity_str: str, cvss_score: Optional[float] = None) -> Severity:
    """
    Parse severity with CVSS score prioritized over exact string mapping.
    
    Args:
        severity_str: Severity string (e.g., "high", "critical")
        cvss_score: CVSS numeric score (prioritized if available)
    
    Returns:
        Severity enum
    """
    # PRIORITY 1: Use CVSS score if available (most reliable)
    if cvss_score is not None:
        return parse_severity_from_cvss(cvss_score)
    
    # PRIORITY 2: Use exact string mapping (CVSS v3 standard terms)
    if not severity_str:
        return Severity.UNKNOWN
    
    # Exact mapping for CVSS v3 standard severity levels
    severity_map = {
        "critical": Severity.CRITICAL,
        "high": Severity.HIGH,
        "medium": Severity.MEDIUM,
        "low": Severity.LOW,
        "unknown": Severity.UNKNOWN,
        "none": Severity.UNKNOWN,  # CVSS sometimes uses "none"
    }
    
    severity_normalized = severity_str.lower().strip()
    return severity_map.get(severity_normalized, Severity.UNKNOWN)


class VulnerabilityAssessor:
    """Assesses vulnerabilities for a given software."""
    
    def __init__(
        self, 
        tavily_api_key: str, 
        google_api_key: str,
        nvd_api_key: Optional[str] = None,
        use_nvd: bool = True
    ):
        """
        Initialize the vulnerability assessor.
        
        Args:
            tavily_api_key: Tavily API key for web search
            google_api_key: Google API key for Gemini
            nvd_api_key: Optional NVD API key for higher rate limits
            use_nvd: Whether to use NVD API as primary source
        """
        self.tavily_client = TavilyClient(api_key=tavily_api_key)
        self.cve_client = CVEDatabaseClient(api_key=nvd_api_key)
        self.use_nvd = use_nvd
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-2.0-flash-exp",
            google_api_key=google_api_key,
            temperature=0  # Deterministic output for consistent results
        )
    
    def verify_software_exists(self, software_name: str) -> dict:
        """Verify if software exists and is real using web search."""
        start_time = time.time()
        
        query = f'"{software_name}" software tool product'
        
        try:
            results = self.tavily_client.search(
                query=query,
                max_results=3,
                search_depth="basic"
            )
            
            elapsed = time.time() - start_time
            
            # Analyze if software seems real
            search_results = results.get("results", [])
            
            # Check if any results actually mention the exact software name
            confidence = "unknown"
            evidence = []
            software_found = False
            
            for result in search_results:
                title = result.get("title", "").lower()
                content = result.get("content", "").lower()
                software_lower = software_name.lower()
                
                # Look for exact or very close matches
                if software_lower in title or software_lower in content:
                    confidence = "high"
                    software_found = True
                    evidence.append(result.get("url", ""))
                    break
            else:
                # No exact matches found
                if len(search_results) > 0:
                    # Found results but software name not mentioned
                    confidence = "low"
                    software_found = False  # Not confident it exists
                else:
                    # No results at all
                    confidence = "none"
                    software_found = False
            
            return {
                "software_name": software_name,
                "exists": software_found,  # Only true if name was found in results
                "confidence": confidence,
                "evidence_urls": evidence,
                "elapsed_time": elapsed
            }
            
        except Exception as e:
            logger.error("Error verifying software existence: %s", e)
            return {
                "software_name": software_name,
                "exists": True,  # Assume exists on error to avoid false negatives
                "confidence": "unknown",
                "evidence_urls": [],
                "elapsed_time": time.time() - start_time,
                "error": str(e)
            }
    
    def search_cves(self, software_name: str) -> List[dict]:
        """Search for CVEs related to the software using Tavily."""
        start_time = time.time()
        
        # Search for CVE information
        query = f"CVE vulnerabilities security issues {software_name}"
        
        try:
            results = self.tavily_client.search(
                query=query,
                max_results=5,
                search_depth="advanced"
            )
            
            elapsed = time.time() - start_time
            
            return {
                "results": results.get("results", []),
                "query": query,
                "elapsed_time": elapsed
            }
        except Exception as e:
            logger.error("Error searching CVEs: %s", e)
            return {
                "results": [],
                "query": query,
                "elapsed_time": time.time() - start_time,
                "error": str(e)
            }
    
    def analyze_vulnerabilities(self, software_name: str, search_results: List[dict]) -> VulnerabilityAssessment:
        """Analyze search results to extract vulnerability information using LLM."""
        start_time = time.time()
        
        # Prepare context from search results with numbered sources
        context = "\n\n".join([
            f"[Source {i+1}]\nTitle: {r.get('title', 'Unknown')}\nURL: {r.get('url', 'N/A')}\nContent: {r.get('content', '')}"
            for i, r in enumerate(search_results)
        ])
        
        prompt = f"""You are a cybersecurity analyst evaluating CVE data for "{software_name}". Analyze if these CVEs apply to this specific software.

Search Results:
{context}

CRITICAL INSTRUCTIONS:
1. ONLY include CVEs that EXPLICITLY mention "{software_name}" or a product clearly identified as "{software_name}"
2. REJECT CVEs for different products with similar names (e.g., "Apache Tiles" ≠ "Tiles", "Go language" ≠ "Goshgoha")
3. For each CVE, assign a confidence level (high/medium/low) based on product name match accuracy
4. Extract CVSS scores from the content when available (look for "CVSS" followed by numbers like 7.5, 9.8)
5. Provide clear reasoning for each match

CONFIDENCE GUIDELINES:
- HIGH: CVE explicitly mentions "{software_name}" by exact name
- MEDIUM: CVE is for a related product/component (e.g., browser plugin of main software)
- LOW: Weak match, similar names, or unclear if it applies (these will be filtered out)

EXAMPLES OF GOOD MATCHES:
✓ Software: "Langflow", Source: "CVE-2025-3248 affects Langflow versions prior to 1.3.0" → HIGH confidence
✓ Software: "Okta Workforce Identity", Source: "Okta Browser Plugin vulnerability" → MEDIUM confidence

EXAMPLES OF BAD MATCHES (MUST REJECT):
✗ Software: "Tiles", Source: "Apache Tiles framework vulnerability" → Reject (different product)
✗ Software: "Goshgoha", Source: "Go language CVE" → Reject (programming language, not the software)
✗ Software: "Base44", Source: "Base64 encoding issue" → Reject (different technology)

Return JSON with this structure:
{{
  "vulnerabilities": [
    {{
      "cve_id": "CVE-YYYY-XXXXX",
      "severity": "critical|high|medium|low",
      "cvss_score": 9.8,
      "description": "Brief description (max 200 chars)",
      "source_number": 1,
      "confidence": "high|medium|low",
      "reasoning": "Why this CVE applies to {software_name}"
    }}
  ],
  "security_update_cadence": "frequent|moderate|infrequent|unknown",
  "overall_confidence": "high|medium|low"
}}

IMPORTANT: 
- Only include CVEs with "high" or "medium" confidence
- If no matching CVEs found, return empty "vulnerabilities" array
- Be conservative - when in doubt, exclude it
- Return ONLY valid JSON, no markdown formatting"""

        try:
            response = self.llm.invoke(prompt)
            analysis = response.content
            
            # Extract token usage and calculate cost
            cost_info = {}
            if hasattr(response, 'response_metadata') and 'token_usage' in response.response_metadata:
                token_usage = response.response_metadata['token_usage']
                input_tokens = token_usage.get('prompt_tokens', 0)
                output_tokens = token_usage.get('completion_tokens', 0)
                cost_info = calculate_cost(input_tokens, output_tokens, "gemini-2.0-flash-exp")
            
            # Parse JSON response with fallback
            try:
                # Try to extract JSON from response (in case it's wrapped in markdown)
                json_match = re.search(r'\{[\s\S]*\}', analysis)
                if json_match:
                    data = json.loads(json_match.group(0))
                else:
                    data = json.loads(analysis)
            except json.JSONDecodeError:
                # Fallback to old parsing method if JSON fails
                logger.warning("Failed to parse JSON response, using fallback parsing")
                vulnerabilities = self._parse_vulnerabilities_from_analysis(analysis)
                data = {
                    "vulnerabilities": [
                        {
                            "cve_id": v.cve_id,
                            "severity": v.severity.value,
                            "description": v.description
                        } for v in vulnerabilities
                    ],
                    "security_update_cadence": "unknown",
                    "analysis_notes": analysis
                }
            
            # Parse vulnerabilities from structured data
            vulnerabilities = []
            filtered_count = 0
            
            for vuln_data in data.get("vulnerabilities", []):
                cve_id = vuln_data.get("cve_id")
                confidence = vuln_data.get("confidence", "low")
                
                # FILTER 1: Only accept high/medium confidence CVEs
                if confidence not in ["high", "medium"]:
                    filtered_count += 1
                    logger.info("Filtered CVE %s: Low confidence match", cve_id)
                    continue
                
                # Validate CVE matches software name
                source_num = vuln_data.get("source_number", 0)
                source_url = None
                
                if source_num > 0 and source_num <= len(search_results):
                    source = search_results[source_num - 1]
                    source_url = source.get("url")
                    source_title = source.get("title", "").lower()
                    source_content = source.get("content", "").lower()
                    software_lower = software_name.lower()
                    
                    # Check if software name appears in the source
                    # This prevents attributing Golang CVEs to Goshgoha
                    if software_lower in source_title or software_lower in source_content:
                        pass  # Valid CVE, continue processing
                    else:
                        # Check for common mismatches
                        # If source mentions different software, reject it
                        filtered_count += 1
                        logger.debug("Filtered CVE %s: Source mentions different software", cve_id)
                        continue
                else:
                    # No source reference - be conservative and reject
                    filtered_count += 1
                    logger.debug("Filtered CVE %s: No valid source reference", cve_id)
                    continue
                
                # Handle None values from JSON
                severity_str = vuln_data.get("severity") or "unknown"
                cvss_score = vuln_data.get("cvss_score")
                # Use CVSS score if available, fallback to string parsing
                severity = parse_severity(severity_str, cvss_score)
                
                vulnerabilities.append(Vulnerability(
                    cve_id=cve_id,
                    severity=severity,
                    cvss_score=cvss_score,
                    description=(vuln_data.get("description") or "No description provided")[:DESCRIPTION_MAX_LENGTH],
                    source_url=source_url
                ))
            
            if filtered_count > 0:
                logger.info("Filtered out %s CVE(s) that didn't match '%s'", filtered_count, software_name)
            
            # DEDUPLICATE: Remove duplicate CVEs (same CVE ID from multiple sources)
            seen_cves = {}
            unique_vulnerabilities = []
            for vuln in vulnerabilities:
                if vuln.cve_id not in seen_cves:
                    seen_cves[vuln.cve_id] = True
                    unique_vulnerabilities.append(vuln)
                else:
                    logger.debug("Removed duplicate CVE: %s", vuln.cve_id)
            
            duplicate_count = len(vulnerabilities) - len(unique_vulnerabilities)
            if duplicate_count > 0:
                logger.info("Removed %d duplicate CVE(s)", duplicate_count)
            vulnerabilities = unique_vulnerabilities
            
            severity_counts = {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "unknown": 0
            }
            
            for vuln in vulnerabilities:
                severity_counts[vuln.severity.value] += 1
            
            has_critical = severity_counts["critical"] > 0
            has_high = severity_counts["high"] > 0
            
            # Get security update cadence from structured response (handle None)
            cadence = data.get("security_update_cadence") or "unknown"
            
            # Create summary
            if len(vulnerabilities) == 0:
                summary = f"No significant vulnerabilities found for {software_name}."
            else:
                summary = f"Found {len(vulnerabilities)} vulnerabilities for {software_name}. "
                if has_critical:
                    summary += f"Includes {severity_counts['critical']} critical issue(s). "
                if has_high:
                    summary += f"Includes {severity_counts['high']} high severity issue(s). "
                summary += f"Security update cadence: {cadence}."
            
            elapsed = time.time() - start_time
            
            # Prepare source data for verification (include title and URL)
            source_data = [
                {
                    "title": r.get("title", ""),
                    "url": r.get("url", ""),
                    "content_preview": r.get("content", "")[:DESCRIPTION_MAX_LENGTH]  # First 200 chars
                }
                for r in search_results
            ]
            
            return VulnerabilityAssessment(
                software_name=software_name,
                vulnerabilities=vulnerabilities,
                total_count=len(vulnerabilities),
                severity_counts=severity_counts,
                has_critical=has_critical,
                has_high=has_high,
                security_update_cadence=cadence,
                summary=summary,
                source_data=source_data,
                software_exists=True,  # Will be updated by assess() method
                existence_confidence="unknown"  # Will be updated by assess() method
            ), analysis, elapsed, cost_info
            
        except Exception as e:
            logger.error("Error analyzing vulnerabilities: %s", e)
            return VulnerabilityAssessment(
                software_name=software_name,
                summary=f"Error analyzing vulnerabilities: {str(e)}"
            ), str(e), time.time() - start_time, {}
    
    def _parse_vulnerabilities_from_analysis(self, analysis: str) -> List[Vulnerability]:
        """Parse vulnerability information from LLM analysis (fallback method)."""
        vulnerabilities = []
        
        # Look for CVE patterns
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        
        # Split analysis into lines for processing
        lines = analysis.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Check if line mentions severity
            severity = None
            for sev in ["critical", "high", "medium", "low"]:
                if sev in line.lower():
                    severity = parse_severity(sev)
                    break
            
            # Check for CVE ID in line
            cve_match = re.search(cve_pattern, line)
            cve_id = cve_match.group(0) if cve_match else None
            
            # If we found a CVE or severity, create a vulnerability
            if cve_id or severity:
                # Extract description (the line without CVE and severity keywords)
                description = re.sub(cve_pattern, '', line)
                description = re.sub(r'\b(critical|high|medium|low)\b', '', description, flags=re.IGNORECASE)
                description = description.strip(' -•:')
                
                if not description:
                    description = "Vulnerability details not specified"
                
                vulnerabilities.append(Vulnerability(
                    cve_id=cve_id,
                    severity=severity or Severity.UNKNOWN,
                    description=description[:DESCRIPTION_MAX_LENGTH]  # Limit description length
                ))
        
        return vulnerabilities
    
    def search_cves_nvd(self, software_name: str) -> dict:
        """Search for CVEs using NVD API directly."""
        return self.cve_client.search_cves(software_name)
    
    def assess(self, software_name: str) -> tuple:
        """
        Perform complete vulnerability assessment.
        
        Uses NVD API as primary source, falls back to Tavily web search.
        Includes software existence validation and CVE verification.
        
        Returns:
            Tuple of (VulnerabilityAssessment, traces)
        """
        traces = []
        
        # Step 0: Verify software exists
        logger.info("Verifying '%s' exists", software_name)
        existence_check = self.verify_software_exists(software_name)
        traces.append({
            "step": "software_verification",
            "tool": "tavily",
            "query": f'"{software_name}" software tool product',
            "elapsed_time": existence_check.get("elapsed_time"),
            "confidence": existence_check.get("confidence"),
            "exists": existence_check.get("exists")
        })
        
        exists = existence_check.get("exists", False)
        confidence = existence_check.get("confidence", "unknown")
        
        if confidence == "none":
            logger.warning("No evidence found that '%s' exists", software_name)
            logger.warning("Results may be unreliable or based on similar-named software")
        elif confidence == "low" or not exists:
            logger.warning("'%s' not found in search results (low confidence)", software_name)
            logger.warning("Software may not exist or have very low online presence")
        elif confidence == "high" and exists:
            logger.info("Software verified: '%s' found with high confidence", software_name)
        else:
            logger.warning("Software verification uncertain for '%s'", software_name)
        
        # Try NVD API first
        if self.use_nvd:
            nvd_result = self.search_cves_nvd(software_name)
            traces.append({
                "step": "cve_search_nvd",
                "tool": "nvd_api",
                "query": nvd_result.get("query"),
                "elapsed_time": nvd_result.get("elapsed_time"),
                "results_count": nvd_result.get("total_results", 0),
                "source": "authoritative"
            })
            
            # If NVD found results, use them
            if nvd_result.get("cves") and not nvd_result.get("error"):
                assessment, _, elapsed, cost_info = self.analyze_vulnerabilities_from_nvd(
                    software_name,
                    nvd_result.get("cves", [])
                )
                
                # Update existence information
                assessment.software_exists = existence_check.get("exists", True)
                assessment.existence_confidence = existence_check.get("confidence", "unknown")
                
                trace_data = {
                    "step": "vulnerability_analysis",
                    "tool": "gemini",
                    "elapsed_time": elapsed,
                    "vulnerabilities_found": assessment.total_count,
                    "data_source": "nvd"
                }
                if cost_info:
                    trace_data["cost"] = cost_info
                traces.append(trace_data)
                return assessment, traces
        
        # Fallback to Tavily web search
        logger.warning("NVD API unavailable, using Tavily web search fallback")
        search_result = self.search_cves(software_name)
        traces.append({
            "step": "cve_search_fallback",
            "tool": "tavily",
            "query": search_result.get("query"),
            "elapsed_time": search_result.get("elapsed_time"),
            "results_count": len(search_result.get("results", [])),
            "source": "web_search"
        })
        
        # Analyze vulnerabilities from web search
        assessment, _, elapsed, cost_info = self.analyze_vulnerabilities(
            software_name,
            search_result.get("results", [])
        )
        
        # Update existence information
        assessment.software_exists = existence_check.get("exists", True)
        assessment.existence_confidence = existence_check.get("confidence", "unknown")
        
        trace_data = {
            "step": "vulnerability_analysis",
            "tool": "gemini",
            "elapsed_time": elapsed,
            "vulnerabilities_found": assessment.total_count,
            "data_source": "tavily"
        }
        if cost_info:
            trace_data["cost"] = cost_info
        traces.append(trace_data)
        
        return assessment, traces
    
    def analyze_vulnerabilities_from_nvd(
        self, 
        software_name: str, 
        cves: List[dict]
    ) -> tuple:
        """Analyze structured CVE data from NVD API."""
        start_time = time.time()
        
        vulnerabilities = []
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "unknown": 0
        }
        
        for cve_data in cves:
            severity_str = cve_data.get("severity", "unknown")
            severity = parse_severity(severity_str)
            
            vuln = Vulnerability(
                cve_id=cve_data.get("cve_id"),
                severity=severity,
                description=cve_data.get("description", "")[:DESCRIPTION_MAX_LENGTH],
                published_date=cve_data.get("published_date")
            )
            vulnerabilities.append(vuln)
            severity_counts[severity.value] += 1
        
        has_critical = severity_counts["critical"] > 0
        has_high = severity_counts["high"] > 0
        
        # Generate summary
        if len(vulnerabilities) == 0:
            summary = f"No vulnerabilities found for {software_name} in NVD database."
        else:
            summary = f"Found {len(vulnerabilities)} vulnerabilities for {software_name}. "
            if has_critical:
                summary += f"Includes {severity_counts['critical']} critical issue(s). "
            if has_high:
                summary += f"Includes {severity_counts['high']} high severity issue(s). "
            summary += "Data from authoritative NVD database."
        
        elapsed = time.time() - start_time
        
        assessment = VulnerabilityAssessment(
            software_name=software_name,
            vulnerabilities=vulnerabilities,
            total_count=len(vulnerabilities),
            severity_counts=severity_counts,
            has_critical=has_critical,
            has_high=has_high,
            security_update_cadence="unknown",  # NVD doesn't provide this
            summary=summary
        )
        
        return assessment, summary, elapsed, {}

